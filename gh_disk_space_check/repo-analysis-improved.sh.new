#!/bin/bash
# Improved repository analysis script with better GitHub repository name resolution
# This script identifies large files in GitHub repositories and resolves repository names correctly using ghe-nwo

# Default configuration - can be overridden by environment variables
SIZE_MIN_MB=${SIZE_MIN_MB:-1}
SIZE_MAX_MB=${SIZE_MAX_MB:-25}
MAX_REPOS=${MAX_REPOS:-10}
MAX_OBJECTS=${MAX_OBJECTS:-10}
INCLUDE_DELETED=${INCLUDE_DELETED:-false}
REPO_BASE=${REPO_BASE:-"/data/user/repositories"}
DEBUG=${DEBUG:-false}
# Comma-separated list of organizations to exclude (default: actions)
EXCLUDE_ORGS=${EXCLUDE_ORGS:-"actions"}

# Parse any command line arguments passed through curl
while [[ $# -gt 0 ]]; do
    case $1 in
        --min-size) SIZE_MIN_MB=$2; shift 2 ;;
        --max-size) SIZE_MAX_MB=$2; shift 2 ;;
        --max-repos) MAX_REPOS=$2; shift 2 ;;
        --max-objects) MAX_OBJECTS=$2; shift 2 ;;
        --include-deleted) INCLUDE_DELETED=true; shift ;;
        --base-path) REPO_BASE=$2; shift 2 ;;
        --exclude-orgs) EXCLUDE_ORGS=$2; shift 2 ;;
        --debug) DEBUG=true; shift ;;
        --help) 
            echo "Improved Repository File Size Analysis for GHES"
            echo "Usage: bash <(curl -sL URL) [options]"
            echo "Environment variables: SIZE_MIN_MB, SIZE_MAX_MB, MAX_REPOS, MAX_OBJECTS, INCLUDE_DELETED, REPO_BASE, EXCLUDE_ORGS"
            echo "  --exclude-orgs    Comma-separated list of organizations to exclude (default: actions)"
            echo "Note: Script automatically uses sudo for repository access when needed"
            exit 0 ;;
        *) shift ;;
    esac
done

# Convert sizes to bytes for calculations
SIZE_MIN_BYTES=$((SIZE_MIN_MB * 1024 * 1024))
SIZE_MAX_BYTES=$((SIZE_MAX_MB * 1024 * 1024))

# Output files
OVER_MAX_FILE="/tmp/repos_over_${SIZE_MAX_MB}mb.txt"
BETWEEN_FILE="/tmp/repos_${SIZE_MIN_MB}mb_to_${SIZE_MAX_MB}mb.txt"

# Initialize output files
> "$OVER_MAX_FILE"
> "$BETWEEN_FILE"

# Temporary file for unmapped repositories
UNMAPPED_REPOS_FILE="/tmp/unmapped_repos.txt"
> "$UNMAPPED_REPOS_FILE"

# Temporary file for excluded repositories
EXCLUDED_REPOS_FILE="/tmp/excluded_repos.txt"
> "$EXCLUDED_REPOS_FILE"

# Repository name cache to avoid repeated ghe-nwo calls
declare -A repo_name_cache

# Function to get human-readable file size
get_human_size() {
    local size_bytes=$1
    if (( size_bytes >= 1073741824 )); then
        echo "$(echo "scale=2; $size_bytes/1073741824" | bc)GB"
    elif (( size_bytes >= 1048576 )); then
        echo "$(echo "scale=2; $size_bytes/1048576" | bc)MB"
    else
        echo "$(echo "scale=2; $size_bytes/1024" | bc)KB"
    fi
}

# Function to check if a repository belongs to an excluded organization
is_excluded_org() {
    local repo_name=$1
    local org_name
    
    # Skip check if no orgs to exclude
    if [[ -z "$EXCLUDE_ORGS" ]]; then
        return 1  # Not excluded
    fi
    
    # Extract the org name (everything before the first slash)
    org_name=$(echo "$repo_name" | cut -d'/' -f1)
    
    # Check if org is in the excluded list
    IFS=',' read -ra EXCLUDED_ORGS <<< "$EXCLUDE_ORGS"
    for excluded in "${EXCLUDED_ORGS[@]}"; do
        if [[ "$org_name" == "$excluded" ]]; then
            return 0  # Excluded
        fi
    done
    
    return 1  # Not excluded
}

# Function to resolve repository name using ghe-nwo
resolve_repo_name() {
    local repo_path=$1
    local full_path
    
    # Check if we already have this repo in our cache
    if [[ -n "${repo_name_cache[$repo_path]}" ]]; then
        echo "${repo_name_cache[$repo_path]}"
        return 0
    fi
    
    # If path doesn't start with the repo base directory, add it
    if [[ ! "$repo_path" =~ ^"$REPO_BASE" ]]; then
        full_path="${REPO_BASE}/${repo_path}"
    else
        full_path="$repo_path"
    fi
    
    # Add .git if not present
    if [[ ! "$full_path" =~ \.git$ ]]; then
        full_path="${full_path}.git"
    fi
    
    # Check if the path exists
    if sudo test -d "$full_path"; then
        # Try to get the name with ghe-nwo
        local friendly_name
        friendly_name=$(sudo ghe-nwo "$full_path" 2>/dev/null)
        
        if [[ -n "$friendly_name" ]]; then
            # Check if this repo belongs to an excluded org
            if is_excluded_org "$friendly_name"; then
                [[ "$DEBUG" == "true" ]] && echo "DEBUG: Excluding $friendly_name (in excluded org)"
                echo "$repo_path:$friendly_name" >> "$EXCLUDED_REPOS_FILE"
                return 2  # Special return code for excluded repos
            fi
            
            # Store in cache
            repo_name_cache["$repo_path"]="$friendly_name"
            repo_name_cache["$full_path"]="$friendly_name"
            
            # Remove .git suffix if present
            local no_git_path="${repo_path%.git}"
            repo_name_cache["$no_git_path"]="$friendly_name"
            
            echo "$friendly_name"
            return 0
        fi
    fi
    
    # If resolution fails, return the original path and add to unmapped list
    echo "$repo_path" >> "$UNMAPPED_REPOS_FILE"
    echo "$repo_path"
    return 1
}

# Main analysis
echo "ANALYSIS SETTINGS:"
echo "- Minimum file size: ${SIZE_MIN_MB}MB"
echo "- Maximum file size: ${SIZE_MAX_MB}MB"
echo "- Max repositories to analyze in detail: $MAX_REPOS"
echo "- Max objects per repository: $MAX_OBJECTS"
echo "- Include deleted repositories: $INCLUDE_DELETED"
echo "- Excluded organizations: $EXCLUDE_ORGS"
echo ""

echo "Analyzing repositories in $REPO_BASE..."

# Get initial size estimate
total_size=$(sudo du -sh "$REPO_BASE" 2>/dev/null | cut -f1)
echo "Initial estimate: $total_size	$REPO_BASE"

echo "Scanning for repositories..."

# Find all Git repositories
mapfile -t all_repos < <(sudo find "$REPO_BASE" -name "*.git" -type d 2>/dev/null | head -1000)

# Filter repositories if not including deleted ones
repos_to_analyze=()
for repo in "${all_repos[@]}"; do
    if [[ "$INCLUDE_DELETED" == "false" ]]; then
        # Skip if repository seems deleted - check for objects directory with pack files
        if ! sudo test -d "$repo/objects" || ! sudo find "$repo" -type f -name "*.pack" 2>/dev/null | grep -q .; then
            continue
        fi
    fi
    repos_to_analyze+=("$repo")
done

total_found=${#repos_to_analyze[@]}
total_all=${#all_repos[@]}

if [[ "$INCLUDE_DELETED" == "false" ]]; then
    excluded=$((total_all - total_found))
    echo "Found $total_found active repositories after filtering (excluded $excluded deleted/empty repositories)"
else
    echo "Found $total_found repositories (no filtering applied)"
fi

if (( total_found == 0 )); then
    echo "No repositories found to analyze."
    exit 0
fi

echo "Performing file scan on all active repositories..."

# First, scan all repositories for large files directly
echo "PHASE 1: Quick scan of all repositories for large files..."
total_storage_kb=0
repos_scanned=0

# Create a temp file for storing repo paths with large files
repo_paths_with_large_files=$(mktemp)

for repo in "${repos_to_analyze[@]}"; do
    repos_scanned=$((repos_scanned + 1))
    
    # Try to resolve the repo name early to check for exclusions
    repo_name=$(sudo ghe-nwo "$repo" 2>/dev/null)
    if [[ -n "$repo_name" ]] && is_excluded_org "$repo_name"; then
        [[ "$DEBUG" == "true" ]] && echo "DEBUG: Skipping excluded repository: $repo_name"
        echo "$repo:$repo_name" >> "$EXCLUDED_REPOS_FILE"
        continue
    fi
    
    # Get repository size for total statistics
    size_kb=$(sudo du -sk "$repo" 2>/dev/null | cut -f1)
    if [[ -n "$size_kb" ]] && (( size_kb > 0 )); then
        ((total_storage_kb += size_kb))
    fi
    
    # Progress indicator every 10 repositories
    if (( repos_scanned % 10 == 0 )); then
        echo "  Progress: Scanned $repos_scanned/$total_found repositories..."
    fi
    
    # Find files larger than minimum size
    min_size_find=$(( SIZE_MIN_MB * 1024 ))  # Convert to KB for find command
    max_size_find=$(( SIZE_MAX_MB * 1024 ))  # Convert to KB for find command
    
    # Extract repo path relative to $REPO_BASE for more consistent naming
    repo_rel_path="${repo#$REPO_BASE/}"
    
    # Add to the list of repo paths for later name resolution
    echo "$repo" >> "$repo_paths_with_large_files"
    
    # Find files larger than max size directly
    if [[ "$DEBUG" == "true" ]]; then
        echo "DEBUG: Scanning $repo for files larger than ${SIZE_MAX_MB}MB"
    fi
    
    sudo find "$repo" -type f -size +${max_size_find}k -print0 2>/dev/null | 
    while IFS= read -r -d '' file; do
        size_bytes=$(sudo stat -c '%s' "$file" 2>/dev/null) || continue
        size_display=$(get_human_size "$size_bytes")
        relative_path=$(echo "$file" | sed "s|$repo/||")
        echo "$repo:$relative_path ($size_display)" >> "$OVER_MAX_FILE"
        [[ "$DEBUG" == "true" ]] && echo "DEBUG: Found large file (over max): $file ($size_display)"
    done
    
    # Find files between min and max size
    if [[ "$DEBUG" == "true" ]]; then
        echo "DEBUG: Scanning $repo for files between ${SIZE_MIN_MB}MB and ${SIZE_MAX_MB}MB"
    fi
    
    sudo find "$repo" -type f -size +${min_size_find}k -size -${max_size_find}k -print0 2>/dev/null |
    while IFS= read -r -d '' file; do
        size_bytes=$(sudo stat -c '%s' "$file" 2>/dev/null) || continue
        size_display=$(get_human_size "$size_bytes")
        relative_path=$(echo "$file" | sed "s|$repo/||")
        echo "$repo:$relative_path ($size_display)" >> "$BETWEEN_FILE"
        [[ "$DEBUG" == "true" ]] && echo "DEBUG: Found large file (between): $file ($size_display)"
    done
done

total_storage_gb=$(echo "scale=2; $total_storage_kb/1024/1024" | bc)
echo "Total repository storage: $total_storage_gb GB across $total_found repositories"

# Deduplicate the result files
echo "Deduplicating result files..."
if [[ -s "$OVER_MAX_FILE" ]]; then
    sort -u "$OVER_MAX_FILE" > "${OVER_MAX_FILE}.tmp" && mv "${OVER_MAX_FILE}.tmp" "$OVER_MAX_FILE"
fi

if [[ -s "$BETWEEN_FILE" ]]; then
    sort -u "$BETWEEN_FILE" > "${BETWEEN_FILE}.tmp" && mv "${BETWEEN_FILE}.tmp" "$BETWEEN_FILE"
fi

# Now resolve repository names for all repos with large files
echo "Resolving repository names using ghe-nwo..."

# Create temporary files for processing
all_repos_with_large_files=$(mktemp)
filtered_over_max_file=$(mktemp)
filtered_between_file=$(mktemp)

# Collect all unique repository paths from both files
awk -F: '{print $1}' "$OVER_MAX_FILE" "$BETWEEN_FILE" 2>/dev/null | sort -u > "$all_repos_with_large_files"

# Count how many repos need resolution
repo_count=$(wc -l < "$all_repos_with_large_files")
echo "Found $repo_count repositories with large files that need name resolution"

# Process each repository path to get the name
repos_resolved=0
repos_excluded=0

while IFS= read -r repo_path; do
    result=$(resolve_repo_name "$repo_path")
    exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        # Successfully resolved
        ((repos_resolved++))
        if [[ "$DEBUG" == "true" ]]; then
            echo "DEBUG: Resolved $repo_path to $result"
        fi
    elif [[ $exit_code -eq 2 ]]; then
        # Excluded repository
        ((repos_excluded++))
        if [[ "$DEBUG" == "true" ]]; then
            echo "DEBUG: Excluded repository: $repo_path"
        fi
    fi
done < "$all_repos_with_large_files"

echo "Successfully resolved $repos_resolved repository names"
if [[ $repos_excluded -gt 0 ]]; then
    echo "Excluded $repos_excluded repositories from the results"
fi

# Filter out excluded organizations from results
echo "Filtering results to exclude specified organizations..."

# Filter function to process files
filter_excluded_orgs() {
    local input_file=$1
    local output_file=$2
    
    > "$output_file"  # Initialize output file
    
    while IFS= read -r line; do
        repo_path=$(echo "$line" | cut -d: -f1)
        rest_of_line=$(echo "$line" | cut -d: -f2-)
        
        # Resolve the repo name first
        friendly_name=$(resolve_repo_name "$repo_path")
        exit_code=$?
        
        # Only include repositories that are not excluded
        if [[ $exit_code -ne 2 ]]; then
            echo "$repo_path:$rest_of_line" >> "$output_file"
        else
            [[ "$DEBUG" == "true" ]] && echo "DEBUG: Filtered out excluded repo: $friendly_name"
        fi
    done < "$input_file"
}

filter_excluded_orgs "$OVER_MAX_FILE" "$filtered_over_max_file"
filter_excluded_orgs "$BETWEEN_FILE" "$filtered_between_file"

# Replace original files with filtered versions
mv "$filtered_over_max_file" "$OVER_MAX_FILE"
mv "$filtered_between_file" "$BETWEEN_FILE"

# Show repository name cache entries if in debug mode
if [[ "$DEBUG" == "true" ]]; then
    echo "Repository name cache entries:"
    for key in "${!repo_name_cache[@]}"; do
        echo "  $key -> ${repo_name_cache[$key]}"
    done
fi

# Generate summary report
echo ""
echo "======================================"
echo "REPOSITORY FILE SIZE ANALYSIS SUMMARY"
echo "======================================"
echo "Total repositories found: $total_found"
echo ""

# Count results
over_max_repos=$(awk -F: '{print $1}' "$OVER_MAX_FILE" 2>/dev/null | sort -u | wc -l)
between_repos=$(awk -F: '{print $1}' "$BETWEEN_FILE" 2>/dev/null | sort -u | wc -l)
over_max_files=$(wc -l < "$OVER_MAX_FILE" 2>/dev/null || echo 0)
between_files=$(wc -l < "$BETWEEN_FILE" 2>/dev/null || echo 0)

echo "FINDINGS SUMMARY:"
echo "----------------"
echo "1. Repositories with files > ${SIZE_MAX_MB}MB: $over_max_repos"
echo "   Total files > ${SIZE_MAX_MB}MB: $over_max_files"
echo ""
echo "2. Repositories with files ${SIZE_MIN_MB}MB-${SIZE_MAX_MB}MB: $between_repos"
echo "   Total files ${SIZE_MIN_MB}MB-${SIZE_MAX_MB}MB: $between_files"
echo ""

# Show top repositories with large files
if (( over_max_repos > 0 )); then
    echo "TOP 5 REPOSITORIES WITH LARGEST FILES:"
    echo "------------------------------------"
    # Use a temporary file for the sorted repo counts
    top_repos_counted=$(mktemp)
    awk -F: '{print $1}' "$OVER_MAX_FILE" | sort | uniq -c | sort -nr | head -5 > "$top_repos_counted"
    
    while read -r count repo_path; do
        # Resolve repository name
        resolved_name=$(resolve_repo_name "$repo_path")
        echo "  $resolved_name: $count large files"
    done < "$top_repos_counted"
    
    rm -f "$top_repos_counted"
    echo ""
fi

# Update the output files to use friendly names
echo "Updating output files with friendly repository names..."

update_output_file() {
    local file=$1
    local temp_file=$(mktemp)
    
    if [[ -s "$file" ]]; then
        while IFS= read -r line; do
            # Extract repo path and the rest of the line
            repo_path=$(echo "$line" | cut -d: -f1)
            rest_of_line=$(echo "$line" | cut -d: -f2-)
            
            # Resolve the repository name
            friendly_name=$(resolve_repo_name "$repo_path")
            exit_code=$?
            
            # Only include if not excluded
            if [[ $exit_code -ne 2 ]]; then
                # Write the line with the friendly name
                echo "$friendly_name:$rest_of_line" >> "$temp_file"
            fi
        done < "$file"
        
        # Replace original file with updated one
        mv "$temp_file" "$file"
    fi
}

update_output_file "$OVER_MAX_FILE"
update_output_file "$BETWEEN_FILE"

# Remove temporary files
rm -f "$all_repos_with_large_files" "$repo_paths_with_large_files"

echo "REPORTS LOCATION:"
echo "---------------"
echo "* Files over ${SIZE_MAX_MB}MB: $OVER_MAX_FILE"
echo "* Files between ${SIZE_MIN_MB}MB-${SIZE_MAX_MB}MB: $BETWEEN_FILE"
echo ""

# Check if any repositories couldn't be resolved
unmapped_count=$(wc -l < "$UNMAPPED_REPOS_FILE" 2>/dev/null || echo 0)
excluded_count=$(wc -l < "$EXCLUDED_REPOS_FILE" 2>/dev/null || echo 0)

if [[ -s "$UNMAPPED_REPOS_FILE" && $unmapped_count -gt 0 ]]; then
    echo "NOTE: $unmapped_count repository paths could not be resolved with ghe-nwo."
    if [[ "$DEBUG" == "true" ]]; then
        echo "Unmapped repositories:"
        sort -u "$UNMAPPED_REPOS_FILE" | head -10 | while read -r path; do
            echo "  $path"
        done
        if (( unmapped_count > 10 )); then
            echo "  ... and $(( unmapped_count - 10 )) more"
        fi
    fi
fi

if [[ -s "$EXCLUDED_REPOS_FILE" && $excluded_count -gt 0 ]]; then
    echo "NOTE: $excluded_count repository paths were excluded based on organization filters."
    if [[ "$DEBUG" == "true" ]]; then
        echo "Excluded repositories:"
        sort -u "$EXCLUDED_REPOS_FILE" | head -10 | while IFS=: read -r path name; do
            echo "  $name ($path)"
        done
        if (( excluded_count > 10 )); then
            echo "  ... and $(( excluded_count - 10 )) more"
        fi
    fi
fi

# Clean up temporary files
rm -f "$UNMAPPED_REPOS_FILE" "$EXCLUDED_REPOS_FILE"

echo "Analysis completed: $(date)"
